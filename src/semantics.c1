// BEGIN setups

struct s_warn_t {
    int row;
    string msg;
};
typedef struct s_warn_t s_warn_t;

// END setups

// BEGIN ast info

struct s_var_info_t {
    ast_type_t *type;
    string name;
};
typedef struct s_var_info_t s_var_info_t;

struct s_strct_info_t {
    bool implemented;

    om_map_t *fld_to_idx; // string -> int
    vec_t *fld_types; // [ast_type_t *]
    vec_t *fld_names; // [string]
};
typedef struct s_strct_info_t s_strct_info_t;

// TODO: pureness checking
struct s_func_info_t {
    bool implemented;

    ast_type_t *ret_type;
    vec_t *prm_types; // [ast_type_t *]
    vec_t *prm_names; // [string]

    // TODO
    bool pure;
};
typedef struct s_func_info_t s_func_info_t;

// END ast info

struct s_scope_t {
    om_map_t *var_map; // string -> s_var_info_t *
};
typedef struct s_scope_t s_scope_t;

// accumulative context; retained across files
struct s_ctx_t {

    om_map_t *alias_map; // string -> ast_type_t *
    om_map_t *strct_map; // string -> s_strct_info_t *
    om_map_t *func_map; // string -> s_func_info_t *
};
typedef struct s_ctx_t s_ctx_t;

// current session for the current file
struct s_session_t {

    // global
    om_map_t *alias_map; // string -> ast_type_t *
    om_map_t *strct_map; // string -> s_strct_info_t *
    om_map_t *func_map; // string -> s_func_info_t *

    // local
    s_func_info_t *curr_func;
    vec_t *var_stack;
    om_map_t *uninit_vars;

    // declared types/functions that must be defined
    // only functions need to be recorded as structs cannot be used outside of
    // type checking prior to being defined
    vec_t *required_funcs; // [string]

    e_error_t *err;
};
typedef struct s_session_t s_session_t;

// BEGIN contracts

bool s_is_ctx(s_ctx_t *ctx) {
    return ctx != NULL
        && __om_is_valid_tree(ctx->alias_map)
        && __om_is_valid_tree(ctx->strct_map)
        && __om_is_valid_tree(ctx->func_map);
}

bool s_is_session(s_session_t *session) {
    return session != NULL
        && __om_is_valid_tree(session->alias_map)
        && __om_is_valid_tree(session->strct_map)
        && __om_is_valid_tree(session->func_map);
}

bool s_is_local_session(s_session_t *session) {
    return s_is_session(session) && session->curr_func != NULL
        && v_is_vector(session->var_stack)
        && __om_is_valid_tree(session->uninit_vars);
}

// END contracts

// BEGIN helper functions

s_ctx_t *s_empty_ctx()
//@ensures s_is_ctx(\result);
{
    s_ctx_t *ctx = alloc(s_ctx_t);
    ctx->alias_map = om_create_map(&string_ptr_compare);
    ctx->strct_map = om_create_map(&string_ptr_compare);
    ctx->func_map = om_create_map(&string_ptr_compare);

    return ctx;
}

s_session_t *s_new_session(s_ctx_t *ctx)
//@requires s_is_ctx(ctx);
//@ensures s_is_session(\result);
{
    s_session_t *session = alloc(s_session_t);
    session->alias_map = ctx->alias_map;
    session->strct_map = ctx->strct_map;
    session->func_map = ctx->func_map;

    return session;
}

void __s_set_err(s_session_t *session, string msg)
//@requires s_is_session(session);
//@requires !e_has_err(session->err);
{
    session->err = e_create_error(msg, NULL);
}

void __s_set_err_pos(s_session_t *session, fr_pos_t *pos, string msg)
//@requires s_is_session(session);
//@requires !e_has_err(session->err);
{
    session->err = e_create_error(msg, pos);
}

s_func_info_t *s_lookup_func(s_session_t *session, string name)
//@requires s_is_session(session);
{
    s_func_info_t *res = (s_func_info_t *) om_get_s(session->func_map, name);
    if (res == NULL) {
        __s_set_err(session, format("function \"%s\" is not defined", name));
        return NULL;
    }

    return res;
}

s_var_info_t *s_lookup_var(s_session_t *session, string name)
//@requires s_is_local_session(session);
{
    for (int i = v_length(session->var_stack) - 1; i > -1; i--) {
        om_map_t *scope = (om_map_t *) v_get(session->var_stack, i);
        s_var_info_t *info = (s_var_info_t *) om_get_s(scope, name);

        if (info != NULL) return info;
    }

    __s_set_err(session, format("variable \"%s\" is not defined", name));
    return NULL;
}

bool __s_assert_valid_type(s_session_t *session, ast_type_t *type)
//@requires s_is_session(session);
//@requires type != NULL;
{
    if (!t_is_valid_type(session->alias_map, session->strct_map, type)) {
        __s_set_err_pos(session, type->pos, "invalid type");
        return false;
    }

    return true;
}

// END helper functions

// BEGIN pass

bool s_pass_struct(s_session_t *session, ast_struct_t *strct)
//@requires s_is_session(session);
{
    om_map_t *structs = session->strct_map;
    s_strct_info_t *info;
    if (om_has_s(structs, strct->name)) {
        info = (s_strct_info_t *) om_get_s(structs, strct->name);
    } else {
        info = alloc(s_strct_info_t);
        info->implemented = false;
        om_insert_s(structs, strct->name, (void *) info);
    }

    if (!strct->defined) return true;

    if (info->implemented) {
        __s_set_err_pos(
            session, strct->pos,
            format("struct \"%s\" is defined twice", strct->name)
        );
        return false;
    }

    info->implemented = true;
    info->fld_to_idx = om_create_map(&string_ptr_compare);
    info->fld_names = v_create_vector();
    info->fld_types = v_create_vector();

    for (int i = 0; i < v_length(strct->mem_types); i++) {
        string fld_name = v_get_string(info->fld_names, i);

        if (om_has_s(info->fld_to_idx, fld_name)) {
            __s_set_err_pos(
                session, strct->pos,
                format("multiple definition of \"%s\"", fld_name)
            );
            return false;
        }

        ast_type_t *fld_type = (ast_type_t *) v_get(info->fld_types, i);
        if (!t_is_small_type(session->alias_map, fld_type)) {
            __s_set_err_pos(
                session, strct->pos,
                format("field \"%s\" is not a small type", fld_name)
            );
            return false;
        }
    }

    return true;
}

bool s_pass_alias(s_session_t *session, ast_alias_t *alias) {

    // TODO: alias pass

    return true;
}

bool s_pass_func(s_session_t *session, ast_func_t *func) {

    // TODO: alias pass

    return true;
}

e_error_t *s_semantics_pass(s_ctx_t *ctx, ast_program_t *prog)
//@requires prog != NULL;
//@requires s_is_ctx(ctx);
{
    s_session_t *session = s_new_session(ctx);

    for (int i = 0; i < v_length(prog->globs); i++) {
        ast_glob_t *glob = (ast_glob_t *) v_get(prog->globs, i);

        if (glob->type == 'F') {
            if (!s_pass_func(session, glob->func)) return session->err;
        } else if (glob->type == 'S') {
            if (!s_pass_struct(session, glob->struc)) return session->err;
        } else if (glob->type == 'T') {
            if (!s_pass_alias(session, glob->alias)) return session->err;
        } else {
            error("unimplemented AST type");
        }
    }

    return NULL;
}

// END pass
