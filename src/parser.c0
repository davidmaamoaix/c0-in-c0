#use <parse>

struct p_ctx_t {
    // declarative information
    om_map_t *types;
    om_map_t *funcs;

    // token tracking
    int n_tokens;
    int pc;
    l_token_t *[] tokens;

    // error handling (propagate instead of throwing)
    bool err;
    string err_msg;
    int err_row;
    int err_col;
};
typedef struct p_ctx_t p_ctx_t;

// BEGIN contracts

bool __p_is_ctx(p_ctx_t *ctx) {
    if (ctx == NULL) return false;
    if (!om_is_valid(ctx->types)) return false;
    if (!om_is_valid(ctx->funcs)) return false;
    
    if (ctx->n_tokens < 0) return false;
    if (!(0 <= ctx->pc && ctx->pc <= ctx->n_tokens)) return false;
    //@assert ctx->n_tokens <= \length(ctx->tokens);

    return true;
}

bool __p_is_eof(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
{
    return ctx->pc == ctx->n_tokens;
}

// END contracts

// BEGIN constructors

p_ctx_t *p_create_ctx(int n_tokens, l_token_t *[] tokens)
//@ensures __p_is_ctx(\result);
{
    p_ctx_t *ctx = alloc(p_ctx_t);
    ctx->types = om_create_map();
    ctx->funcs = om_create_map();

    ctx->n_tokens = n_tokens;
    ctx->tokens = tokens;

    return ctx;
}

// END constructors

// BEGIN shorthands

void __p_set_err(p_ctx_t *ctx, string msg);
void __p_set_err_at(p_ctx_t *ctx, string msg, l_token_t *tok);
void __p_eof_err(p_ctx_t *ctx);
bool __p_expect(char type, string word, p_ctx_t *ctx);
bool __p_expect_kw(string kwd, p_ctx_t *ctx);
bool __p_expect_sep(string sep, p_ctx_t *ctx);
l_token_t *__p_peek(p_ctx_t *ctx);
l_token_t *__p_next(p_ctx_t *ctx);
bool __p_can_be_var(string var, p_ctx_t *ctx);

void __p_set_err(p_ctx_t *ctx, string msg)
//@requires __p_is_ctx(ctx);
//@requires !ctx->err;
//@ensures ctx->err;
{
    ctx->err = true;
    ctx->err_msg = msg;

    if (__p_is_eof(ctx)) {
        ctx->err_row = -1;
        ctx->err_col = -1;
    } else {
        l_token_t *curr = __p_peek(ctx);
        ctx->err_row = curr->row;
        ctx->err_col = curr->col;
    }
}

void __p_set_err_at(p_ctx_t *ctx, string msg, l_token_t *tok)
//@requires __p_is_ctx(ctx);
//@requires !ctx->err;
//@ensures ctx->err;
{
    ctx->err = true;
    ctx->err_msg = msg;
    ctx->err_row = tok->row;
    ctx->err_col = tok->col;
}

void __p_eof_err(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@requires !ctx->err;
//@ensures ctx->err;
{
    __p_set_err(ctx, "unexpected end of file");
}

bool __p_match(l_token_t *tok, char type, string word) {
    return tok->type == type && string_equal(tok->str, word);
}

bool __p_expect(char type, string word, p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@requires u_is_token_type(type);
//@ensures \result && !ctx->err || !\result && ctx->err;
{
    if (__p_is_eof(ctx)) {
        __p_eof_err(ctx);
        return false;
    }

    l_token_t *tok = ctx->tokens[ctx->pc];
    ctx->pc++;

    if (!__p_match(tok, type, word)) {
        ctx->err = true;
        ctx->err_msg = format(
            "expecting %s \"%s\", got %s \"%s\"",
            u_tok_type_to_readable(type), word,
            u_tok_type_to_readable(tok->type), tok->str
        );

        return false;
    }

    return true;
}

bool __p_expect_kw(string kwd, p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@ensures \result && !ctx->err || !\result && ctx->err;
{
    return __p_expect('K', kwd, ctx);
}

bool __p_expect_sep(string sep, p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@ensures \result && !ctx->err || !\result && ctx->err;
{
    return __p_expect('S', sep, ctx);
}

l_token_t *__p_peek(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@requires !__p_is_eof(ctx);
{
    return ctx->tokens[ctx->pc];
}

l_token_t *__p_next(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@requires !__p_is_eof(ctx);
{
    l_token_t *tok = ctx->tokens[ctx->pc];
    ctx->pc++;
    return tok;
}

bool __p_can_be_var(string var, p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
{
    return !om_has_s(ctx->types, var) && !om_has_s(ctx->funcs, var);
}

// END shorthands

// BEGIN fset for types

// firset-set of left-recursion eliminated rule of TYPE
bool __p_fset_typel(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
{
    if (__p_is_eof(ctx)) return false;

    l_token_t *tok = __p_peek(ctx);
    return __p_match(tok, 'S', "[") || __p_match(tok, 'O', "*");
}

bool __p_fset_type(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
{
    if (__p_is_eof(ctx)) return false;

    l_token_t *tok = __p_peek(ctx);
    string word = tok->str;
    if (tok->type == 'K') {
        return u_is_native_type(word) || string_equal(word, "struct");
    }

    // check type definitions for `struct <word>`
    if (tok->type == 'I') {
        return om_has_s(ctx->types, word);
    }

    return false;
}

// END fset for types

// BEGIN type production rules

ast_type_t *__p_parse_type(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@requires !__p_is_eof(ctx);
//@requires __p_fset_type(ctx);
//@ensures \result == NULL && ctx->err || \result != NULL && !ctx->err;
{
    ast_type_t *type = alloc(ast_type_t);
    l_token_t *tok = __p_next(ctx);

    if (tok->type == 'K') {
        string word = tok->str;

        if (string_equal(word, "int")) type->type = 'I';
        else if (string_equal(word, "bool")) type->type = 'B';
        else if (string_equal(word, "string")) type->type = 'S';
        else if (string_equal(word, "char")) type->type = 'C';
        else if (string_equal(word, "void")) type->type = 'V';
        else if (string_equal(word, "struct")) {

            if (__p_is_eof(ctx)) {
                __p_eof_err(ctx);
                return NULL;
            }

            l_token_t *iden = __p_next(ctx);
            if (iden->type != 'I') {
                __p_set_err_at(
                    ctx, "expecting identifier after keyword \"struct\"", iden
                );
                return NULL;
            }

            if (!om_has_s(ctx->types, string_join("$", iden->str))) {
                __p_set_err_at(
                    ctx, format("struct \"%s\" is not defined", iden->str), iden
                );
                return NULL;
            }

            type->type = 'X';
            type->iden = iden->str;
        }

    } else if (tok->type == 'I') {
        // sanity check: first-set of TYPE already ensured this
        assert(om_has_s(ctx->types, tok->str));

        type->type = 'D';
        type->iden = tok->str;
    } else {
        error("unreachable by first-set exclusion");
    }

    while (__p_fset_typel(ctx)) {
        l_token_t *curr = __p_next(ctx);
        ast_type_t *outer = alloc(ast_type_t);

        if (__p_match(curr, 'S', "[")) {
            if (!__p_expect_sep("]", ctx)) return NULL;

            outer->type = 'A';
        } else if (__p_match(curr, 'O', "*")) {
            outer->type = 'P';
        } else {
            error("unreachable by first-set exclusion");
        }

        outer->content = type;
        type = outer;
    }

    return type;
}

// END type production rules

// BEGIN fset for expressions

bool __p_fset_exp(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
{
    if (__p_is_eof(ctx)) return false;

    l_token_t *tok = __p_peek(ctx);
    if (__p_match(tok, 'S', "(")) return true;
    if (tok->type == 'L') return true;
    if (tok->type == 'I' && __p_can_be_var(tok->str, ctx)) return true;
    if (__p_match(tok, 'K', "alloc")) return true;
    if (__p_match(tok, 'K', "alloc_array")) return true;

    return false;
}

// END fset for expressions

// BEGIN expression production rules
// this is gonna be hell; check `syntax.cf` for precedence info

ast_exp_t *__p_parse_exp0(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp1(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp2(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp3(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp4(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp5(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp6(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp7(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp8(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp9(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp10(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp11(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp12(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp13(p_ctx_t *ctx);
ast_exp_t *__p_parse_exp(p_ctx_t *ctx);

ast_exp_t *__p_parse_exp0(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@requires !__p_is_eof(ctx);
//@requires __p_fset_exp(ctx);
//@ensures \result == NULL && ctx->err || \result != NULL && !ctx->err;
{
    ast_exp_t *exp = alloc(ast_exp_t);
    l_token_t *tok = __p_next(ctx);

    // parenthesized expression
    if (__p_match(tok, 'S', "(")) {

        // yay alloc and immediate dealloc im very good at programming
        exp = __p_parse_exp(ctx);
        if (exp == NULL) return NULL;
        if (!__p_expect_sep(")", ctx)) return NULL;

    // literal
    } else if (tok->type == 'L') {
        string lit_str = tok->str;
        char fst = string_charat(lit_str, 0);

        if (fst == '\'') {
            exp->type = 'C';
            exp->lit_chr = string_charat(lit_str, 1);
        } else if (fst == '"') {
            exp->type = 'S';
            exp->lit_str = string_sub(lit_str, 1, string_length(lit_str) - 1);
        } else if (string_equal(lit_str, "true")) {
            exp->type = 'B';
            exp->lit_boo = true;
        } else if (string_equal(lit_str, "false")) {
            exp->type = 'B';
            exp->lit_boo = false;
        } else if (string_equal(lit_str, "NULL")) {
            exp->type = 'N';
        } else {
            exp->type = 'I';
            int *parsed = parse_int(lit_str, 10);
            if (parsed == NULL) {
                // sanity check: someone slipped in an invalid integer literal!
                error("invalid integer literal");
            }

            exp->lit_int = *parsed;
        }

    // identifier
    } else if (tok->type == 'I') {
        string iden = tok->str;
        if (!__p_can_be_var(iden, ctx)) {
            error("unreachable code by first-set exclusion");
        }

        if (!__p_is_eof(ctx) && __p_match(__p_peek(ctx), 'S', "(")) {
            // TODO: func call parsing
            error("func call parsing not implemented");
        } else {
            exp->type = 'D';
            exp->iden = iden;
        }

    // `alloc`
    } else if (__p_match(tok, 'K', "alloc")) {
        exp->type = 'A';
        if (!__p_expect_sep("(", ctx)) return NULL;

        if (!__p_fset_type(ctx)) {
            __p_set_err(ctx, "expecting type in \"alloc\"");
            return NULL;
        }
        exp->alloc_type = __p_parse_type(ctx);
        if (exp->alloc_type == NULL) return NULL;

        if (!__p_expect_sep(")", ctx)) return NULL;

    // `alloc_array`
    } else if (__p_match(tok, 'K', "alloc_array")) {
        exp->type = 'R';
        if (!__p_expect_sep("(", ctx)) return NULL;

        if (!__p_fset_type(ctx)) {
            __p_set_err(ctx, "expecting type in \"alloc_array\"");
            return NULL;
        }
        exp->alloc_type = __p_parse_type(ctx);
        if (exp->alloc_type == NULL) return NULL;

        if (!__p_expect_sep(",", ctx)) return NULL;

        if (!__p_fset_exp(ctx)) {
            __p_set_err(ctx, "expecting expression in \"alloc_array\"");
            return NULL;
        }
        exp->alloc_length = __p_parse_exp(ctx);
        if (exp->alloc_type == NULL) return NULL;

        if (!__p_expect_sep(")", ctx)) return NULL;

    } else {
        error("unreachable by first-set exclusion");
    }

    // TODO: bracket suffix check

    return exp;
}

ast_exp_t *__p_parse_exp(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@requires !__p_is_eof(ctx);
//@requires __p_fset_exp(ctx);
//@ensures \result == NULL && ctx->err || \result != NULL && !ctx->err;
{
    return __p_parse_exp0(ctx);
}

// END expression production rules

// BEGIN parsing stage

ast_program_t *p_parse_tokens(int n_tokens, l_token_t *[] tokens)
//@requires n_tokens <= \length(tokens);
{
    p_ctx_t *ctx = p_create_ctx(n_tokens, tokens);

    ast_program_t *prog = alloc(ast_program_t);

    return prog;
}

// END parsing stage
