struct p_ctx_t {
    // declarative information
    om_map_t *types;
    om_map_t *funcs;

    // token tracking
    int n_tokens;
    int pc;
    l_token_t *[] tokens;

    // error handling (propagate instead of throwing)
    bool err;
    string err_msg;
};
typedef struct p_ctx_t p_ctx_t;

// BEGIN contracts

bool __p_is_ctx(p_ctx_t *ctx) {
    if (ctx == NULL) return false;
    if (!om_is_valid(ctx->types)) return false;
    if (!om_is_valid(ctx->funcs)) return false;

    if (ctx->n_tokens < 0) return false;
    if (!(0 <= ctx->pc && ctx->pc < ctx->n_tokens)) return false;
    //@assert ctx->n_tokens <= \length(ctx->tokens);

    return true;
}

bool __p_is_eof(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
{
    return ctx->pc == ctx->n_tokens;
}

// END contracts

// BEGIN constructors

p_ctx_t *p_create_ctx(int n_tokens, l_token_t *[] tokens)
//@ensures __p_is_ctx(\result);
{
    p_ctx_t *ctx = alloc(p_ctx_t);
    ctx->types = om_create_map();
    ctx->funcs = om_create_map();

    ctx->n_tokens = n_tokens;
    ctx->tokens = tokens;

    return ctx;
}

// END constructors

// BEGIN shorthands

void __p_eof_err(p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
{
    ctx->err = true;
    ctx->err_msg = "unexpected end of file";
}

bool __p_expect(char type, string word, p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@requires u_is_token_type(type);
//@ensures \result && !ctx->err || !\result && ctx->err;
{
    if (__p_is_eof(ctx)) {
        __p_eof_err(ctx);
        return false;
    }

    l_token_t *tok = ctx->tokens[ctx->pc];
    ctx->pc++;

    if (tok->type != type || !string_equal(tok->str, word)) {
        ctx->err = true;
        ctx->err_msg = format(
            "expecting %s \"%s\", got %s \"%s\"",
            u_tok_type_to_readable(type), word,
            u_tok_type_to_readable(tok->type), tok->str
        );

        return false;
    }

    return true;
}

bool __p_expect_kw(string kwd, p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@ensures \result && !ctx->err || !\result && ctx->err;
{
    return __p_expect('K', kwd, ctx);
}

bool __p_expect_sep(string sep, p_ctx_t *ctx)
//@requires __p_is_ctx(ctx);
//@ensures \result && !ctx->err || !\result && ctx->err;
{
    return __p_expect('S', sep, ctx);
}

// END shorthands

// BEGIN parsing stage

ast_program_t *parse_tokens(int n_tokens, l_token_t *[] tokens)
//@requires n_tokens <= \length(tokens);
{
    p_ctx_t *ctx = p_create_ctx(n_tokens, tokens);

    ast_program_t *prog = alloc(ast_program_t);

    return prog;
}

// END parsing stage
