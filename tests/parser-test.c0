#use <parse>

bool pt_is_type(ast_type_t *type, char expected) {
    return type != NULL && type->type == expected;
}

bool pt_is_exp(ast_exp_t *exp, char expected) {
    return exp != NULL && exp->type == expected;
}

p_ctx_t *pt_make_ctx(string code, string type_names) {
    l_token_t *[] tokens = alloc_array(l_token_t *, 65536);
    int n_tokens = l_tokenize(code, tokens);
    assert(n_tokens != -1);

    p_ctx_t *ctx = p_create_ctx(n_tokens, tokens);

    int n_types = num_tokens(type_names);
    string[] types = parse_tokens(type_names);
    for (int i = 0; i < n_types; i++) {
        om_insert_s(ctx->types, types[i], 0);
    }

    return ctx;
}

void pt_test_type_basic() {
    ast_type_t *type;
    p_ctx_t *ctx;

    // basic types

    ctx = pt_make_ctx("int", "");
    assert(pt_is_type(__p_parse_type(ctx), 'I'));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("bool", "");
    assert(pt_is_type(__p_parse_type(ctx), 'B'));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("string", "");
    assert(pt_is_type(__p_parse_type(ctx), 'S'));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("char", "");
    assert(pt_is_type(__p_parse_type(ctx), 'C'));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("void", "");
    assert(pt_is_type(__p_parse_type(ctx), 'V'));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("struct foo", "$foo");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'X'));
    assert(string_equal(type->iden, "foo"));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("foo", "foo");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'D'));
    assert(string_equal(type->iden, "foo"));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("HELLO_wOrLd", "HELLO_wOrLd");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'D'));
    assert(string_equal(type->iden, "HELLO_wOrLd"));
    assert(__p_is_eof(ctx));

    // failing parses
    // only failing `struct` tested as fset excludes the rest

    ctx = pt_make_ctx("struct foo", "");
    assert(__p_parse_type(ctx) == NULL && ctx->err);

    ctx = pt_make_ctx("struct foo", "foo");
    assert(__p_parse_type(ctx) == NULL && ctx->err);

    ctx = pt_make_ctx("struct foo", "");
    assert(__p_parse_type(ctx) == NULL && ctx->err);

    ctx = pt_make_ctx("struct", "foo");
    assert(__p_parse_type(ctx) == NULL && ctx->err);

    ctx = pt_make_ctx("struct string", "");
    assert(__p_parse_type(ctx) == NULL && ctx->err);
}

void pt_test_type_suffix() {
    ast_type_t *type;
    p_ctx_t *ctx;

    // basic pointers

    ctx = pt_make_ctx("int* ", "");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'P'));
    assert(pt_is_type(type->content, 'I'));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("string ***", "");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'P'));
    assert(pt_is_type(type->content, 'P'));
    assert(pt_is_type(type->content->content, 'P'));
    assert(pt_is_type(type->content->content->content, 'S'));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("struct FOO **", "$FOO");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'P'));
    assert(pt_is_type(type->content, 'P'));
    assert(pt_is_type(type->content->content, 'X'));
    assert(string_equal(type->content->content->iden, "FOO"));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("I_HATE_15122 *", "I_HATE_15122");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'P'));
    assert(pt_is_type(type->content, 'D'));
    assert(string_equal(type->content->iden, "I_HATE_15122"));
    assert(__p_is_eof(ctx));

    // basic arrays

    ctx = pt_make_ctx("int[]", "");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'A'));
    assert(pt_is_type(type->content, 'I'));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("struct FOO[][]", "$FOO");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'A'));
    assert(pt_is_type(type->content, 'A'));
    assert(pt_is_type(type->content->content, 'X'));
    assert(string_equal(type->content->content->iden, "FOO"));
    assert(__p_is_eof(ctx));

    // basic fails

    ctx = pt_make_ctx("struct [][]", "");
    type = __p_parse_type(ctx);
    assert(type == NULL && ctx->err);

    ctx = pt_make_ctx("int [[]", "");
    type = __p_parse_type(ctx);
    assert(type == NULL && ctx->err);

    ctx = pt_make_ctx("string [][][][", "");
    type = __p_parse_type(ctx);
    assert(type == NULL && ctx->err);

    ctx = pt_make_ctx("HELLO [][][]]", "HELLO");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'A'));
    assert(!__p_is_eof(ctx));

    ctx = pt_make_ctx("int []*[)", "");
    type = __p_parse_type(ctx);
    assert(type == NULL && ctx->err);

    // mixing pointers and arrays
    ctx = pt_make_ctx("l_token_t *[]", "l_token_t");
    type = __p_parse_type(ctx);
    assert(pt_is_type(type, 'A'));
    assert(pt_is_type(type->content, 'P'));
    assert(pt_is_type(type->content->content, 'D'));
    assert(string_equal(type->content->content->iden, "l_token_t"));
    assert(__p_is_eof(ctx));
}

void pt_test_exp_basic() {
    ast_exp_t *exp;
    p_ctx_t *ctx;

    // basic expressions

    ctx = pt_make_ctx("123", "");
    exp = __p_parse_exp(ctx);
    assert(pt_is_exp(exp, 'I'));
    assert(exp->lit_int == 123);
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("heLLo", "");
    exp = __p_parse_exp(ctx);
    assert(pt_is_exp(exp, 'D'));
    assert(string_equal(exp->iden, "heLLo"));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("true", "");
    exp = __p_parse_exp(ctx);
    assert(pt_is_exp(exp, 'B'));
    assert(exp->lit_boo);
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("false", "");
    exp = __p_parse_exp(ctx);
    assert(pt_is_exp(exp, 'B'));
    assert(!exp->lit_boo);
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("(NULL)", "");
    exp = __p_parse_exp(ctx);
    assert(pt_is_exp(exp, 'N'));
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("hello(1, 1, 64)", "hi");
    exp = __p_parse_exp(ctx);
    assert(pt_is_exp(exp, 'F'));
    assert(exp->n_params == 3);
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("foo()", "");
    exp = __p_parse_exp(ctx);
    assert(pt_is_exp(exp, 'F'));
    assert(exp->n_params == 0);
    assert(__p_is_eof(ctx));

    ctx = pt_make_ctx("foo(bar(), baz(rec(), rec2()))", "");
    exp = __p_parse_exp(ctx);
    assert(pt_is_exp(exp, 'F'));
    assert(exp->n_params == 2);
    assert(__p_is_eof(ctx));
}

void pt_test_parser() {
    pt_test_type_basic();
    pt_test_type_suffix();

    pt_test_exp_basic();
}